<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS 计步器开发]]></title>
      <url>%2F2016%2F12%2F07%2FiOS-%E8%AE%A1%E6%AD%A5%E5%99%A8%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[在微信运动、QQ健康等泛滥的年代，我们公司也终于要搞一个计步器，特此记录。 对于使用了M7或者M8处理器的设备（iPhone5s、iPhone6、iPhone6 Plus、iPhone6s、iPhone6s Plus、），Core Motion框架支持了一些预置的motion动作，比如步数、爬楼还有移动类型(行走、骑行等等)。 所以计步器的开发其实很简单，我们只需要用Core Motion框架就可以直接从设备读取监测了。当然我们还可以用HealthKit进行开发，在这里我们不进行详细的介绍。 Core Motion中的CMStepCounter和CMPedometer是我们今天的重点。 CMPedometer 在iOS8及其以上系统中我们可以使用CMPedometer类获取行走相关信息（步数、距离、上楼、下楼、当前速度等）。 当前设备是否可以获取步数1+ (BOOL)isStepCountingAvailable; 当前设备是否可以获取距离1+ (BOOL)isDistanceAvailable; 当前设备是否可以获取上下楼层数1+ (BOOL)isFloorCountingAvailable; 当前设备是否可以获取速度（s/m）1+ (BOOL)isPaceAvailable 当前设备是否可以获取节奏1+ (BOOL)isCadenceAvailable 根据开始和结束时间查询行走相关信息123- (void)queryPedometerDataFromDate:(NSDate *)starttoDate:(NSDate *)endwithHandler:(CMPedometerHandler)handler; 从某一时刻开始监测步数变化12- (void)startPedometerUpdatesFromDate:(NSDate *)startwithHandler:(CMPedometerHandler)handler; 停止监测步数变化1- (void)stopPedometerUpdates; CMStepCounter 在iOS7中我们只能使用CMStepCounter类获取步数，并且仅能够获取步数。 判断步数统计是否有效1+ (BOOL)isStepCountingAvailable; 根据开始和结束时间查询步数1234- (void)queryStepCountStartingFrom:(NSDate *)startto:(NSDate *)endtoQueue:(NSOperationQueue *)queuewithHandler:(CMStepQueryHandler)handler; 开始断监测步数变化123- (void)startStepCountingUpdatesToQueue:(NSOperationQueue *)queueupdateOn:(NSInteger)stepCountswithHandler:(CMStepUpdateHandler)handler; 停止监测步数变化1- (void)stopStepCountingUpdates; 总结 综上我们可以看出CMPedometer类可以获取的运动信息更加详细。而CMStepCounter类仅能够获取步数。我们在使用中需要判断系统版本使用不同的类获取行走信息。 我对CMPedometer 和CMStepCounter做了简单封装，使得你只需要一行代码就可以获取及监测行走信息。 代码奉上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS多线程编程理解-GCD]]></title>
      <url>%2F2016%2F12%2F07%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%A7%A3-GCD%2F</url>
      <content type="text"><![CDATA[####创建队列 创建串行队列12dispatch_queue_t queue2 =dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_SERIAL); 创建并行队列12dispatch_queue_t queue2 =dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_CONCURRENT); 获取全局队列1dispatch_queue_t queue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) ####系统提供dispatch方法 创建异步任务，不阻塞当前线程，后台执行123dispatch_async(queue3, ^&#123; &#125;); 创建同步任务，阻塞当前线程12dispatch_sync(queue1, ^&#123; &#125;); 主线程执行12dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;); 一次性执行123static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;&#125;); 延迟 2 秒执行1234double delayInSeconds = 2.0;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;&#125;); 创建队列组1dispatch_group_t group = dispatch_group_create(); ####例子eg.11234567891011121314151617//创建串行队列dispatch_queue_t queue2 =dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_SERIAL);//创建异步任务，不阻塞当前线程dispatch_async(queue2, ^&#123; for (int i=0; i&lt;=100; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;); NSLog(@&quot;aaaaa&quot;);//创建异步任务，不阻塞当前线程dispatch_async(queue2, ^&#123; for (int i=101; i&lt;=200; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;);NSLog(@&quot;bbbbb&quot;); 打印结果如下，由打印结果可以看出dispatch_async没有阻塞当前线程，会另开一个线程。而串行队列queue2则会保证，在另一个线程中的任务顺序执行。12345678910111213141516171819202122232016-09-19 10:11:21.090 ThreadTest[3142:78551] _______02016-09-19 10:11:21.089 ThreadTest[3142:78508] aaaaa2016-09-19 10:11:21.091 ThreadTest[3142:78508] bbbbb2016-09-19 10:11:21.091 ThreadTest[3142:78551] _______12016-09-19 10:11:21.092 ThreadTest[3142:78551] _______22016-09-19 10:11:21.093 ThreadTest[3142:78551] _______32016-09-19 10:11:21.094 ThreadTest[3142:78551] _______42016-09-19 10:11:21.094 ThreadTest[3142:78551] _______52016-09-19 10:11:21.094 ThreadTest[3142:78551] _______62016-09-19 10:11:21.095 ThreadTest[3142:78551] _______72016-09-19 10:11:21.095 ThreadTest[3142:78551] _______82016-09-19 10:11:21.095 ThreadTest[3142:78551] _______92016-09-19 10:11:21.096 ThreadTest[3142:78551] _______102016-09-19 10:11:21.096 ThreadTest[3142:78551] _______112016-09-19 10:11:21.096 ThreadTest[3142:78551] _______122016-09-19 10:11:21.096 ThreadTest[3142:78551] _______132016-09-19 10:11:21.097 ThreadTest[3142:78551] _______142016-09-19 10:11:21.097 ThreadTest[3142:78551] _______152016-09-19 10:11:21.097 ThreadTest[3142:78551] _______162016-09-19 10:11:21.097 ThreadTest[3142:78551] _______172016-09-19 10:11:21.098 ThreadTest[3142:78551] _______182016-09-19 10:11:21.098 ThreadTest[3142:78551] _______192016-09-19 10:11:21.099 ThreadTest[3142:78551] _______20 eg.2123456789101112131415161718//创建并行队列 dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_CONCURRENT); //创建异步任务，不阻塞当前线程 dispatch_async(queue3, ^&#123; for (int i=0; i&lt;=10; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125; &#125;); NSLog(@&quot;aaaaa&quot;); //创建异步任务，不阻塞当前线程 dispatch_async(queue3, ^&#123; for (int i=11; i&lt;=20; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125; &#125;); NSLog(@&quot;bbbbb&quot;); 由下方打印结果可以看出dispatch_async会另开一个线程，不阻塞当前线程。而并行队列queue3则会导致另开线程中的任务并发执行。12345678910111213141516171819202122232016-09-19 10:18:24.252 ThreadTest[3199:82172] aaaaa2016-09-19 10:18:24.252 ThreadTest[3199:82208] _______02016-09-19 10:18:24.254 ThreadTest[3199:82172] bbbbb2016-09-19 10:18:24.254 ThreadTest[3199:82208] _______12016-09-19 10:18:24.254 ThreadTest[3199:82210] _______112016-09-19 10:18:24.254 ThreadTest[3199:82208] _______22016-09-19 10:18:24.255 ThreadTest[3199:82210] _______122016-09-19 10:18:24.255 ThreadTest[3199:82208] _______32016-09-19 10:18:24.255 ThreadTest[3199:82210] _______132016-09-19 10:18:24.255 ThreadTest[3199:82208] _______42016-09-19 10:18:24.255 ThreadTest[3199:82210] _______142016-09-19 10:18:24.256 ThreadTest[3199:82208] _______52016-09-19 10:18:24.256 ThreadTest[3199:82210] _______152016-09-19 10:18:24.256 ThreadTest[3199:82208] _______62016-09-19 10:18:24.256 ThreadTest[3199:82210] _______162016-09-19 10:18:24.256 ThreadTest[3199:82208] _______72016-09-19 10:18:24.256 ThreadTest[3199:82210] _______172016-09-19 10:18:24.257 ThreadTest[3199:82208] _______82016-09-19 10:18:24.257 ThreadTest[3199:82210] _______182016-09-19 10:18:24.257 ThreadTest[3199:82208] _______92016-09-19 10:18:24.258 ThreadTest[3199:82210] _______192016-09-19 10:18:24.258 ThreadTest[3199:82208] _______102016-09-19 10:18:24.258 ThreadTest[3199:82210] _______20 eg.3123456789101112131415161718//创建并行队列dispatch_queue_t queue3 =dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_CONCURRENT);//创建异步任务，不阻塞当前线程dispatch_sync(queue3, ^&#123; for (int i=0; i&lt;=10; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;);NSLog(@&quot;aaaaa&quot;);//创建异步任务，不阻塞当前线程dispatch_sync(queue3, ^&#123; for (int i=11; i&lt;=20; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;);NSLog(@&quot;bbbbb&quot;); 123456789101112131415161718//创建串行队列dispatch_queue_t queue2 =dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_SERIAL);//创建异步任务，不阻塞当前线程dispatch_sync(queue2, ^&#123; for (int i=0; i&lt;=10; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;);NSLog(@&quot;aaaaa&quot;);//创建异步任务，不阻塞当前线程dispatch_sync(queue2, ^&#123; for (int i=11; i&lt;=20; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125;&#125;);NSLog(@&quot;bbbbb&quot;); 上面两段代码的打印结果相同，如下所示。由此可以看出不管队列是串行和并行dispatch_sync都会阻塞当前线程。是否阻塞当前线程和队列无关，仅和任务有关。12345678910111213141516171819202122232016-09-19 10:23:05.241 ThreadTest[3283:85234] _______02016-09-19 10:23:05.242 ThreadTest[3283:85234] _______12016-09-19 10:23:05.242 ThreadTest[3283:85234] _______22016-09-19 10:23:05.242 ThreadTest[3283:85234] _______32016-09-19 10:23:05.243 ThreadTest[3283:85234] _______42016-09-19 10:23:05.243 ThreadTest[3283:85234] _______52016-09-19 10:23:05.243 ThreadTest[3283:85234] _______62016-09-19 10:23:05.243 ThreadTest[3283:85234] _______72016-09-19 10:23:05.243 ThreadTest[3283:85234] _______82016-09-19 10:23:05.244 ThreadTest[3283:85234] _______92016-09-19 10:23:05.244 ThreadTest[3283:85234] _______102016-09-19 10:23:05.244 ThreadTest[3283:85234] aaaaa2016-09-19 10:23:05.244 ThreadTest[3283:85234] _______112016-09-19 10:23:05.244 ThreadTest[3283:85234] _______122016-09-19 10:23:05.245 ThreadTest[3283:85234] _______132016-09-19 10:23:05.245 ThreadTest[3283:85234] _______142016-09-19 10:23:05.245 ThreadTest[3283:85234] _______152016-09-19 10:23:05.245 ThreadTest[3283:85234] _______162016-09-19 10:23:05.245 ThreadTest[3283:85234] _______172016-09-19 10:23:05.245 ThreadTest[3283:85234] _______182016-09-19 10:23:05.246 ThreadTest[3283:85234] _______192016-09-19 10:23:05.246 ThreadTest[3283:85234] _______202016-09-19 10:23:05.246 ThreadTest[3283:85234] bobby eg.4123456789101112131415161718192021222324 //创建队列组 dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue3 = //创建并行队列 dispatch_queue_create(&quot;com.quanya.queue&quot;, DISPATCH_QUEUE_CONCURRENT); //创建异步任务，不阻塞当前线程 dispatch_group_async(group,queue3, ^&#123; for (int i=0; i&lt;=10; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125; &#125;); NSLog(@&quot;aaaaa&quot;); //创建异步任务，不阻塞当前线程 dispatch_group_async(group,queue3, ^&#123; for (int i=11; i&lt;=20; i++) &#123; NSLog(@&quot;_______%d&quot;,i); &#125; &#125;); //4.都完成后会自动通知 dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;_______完成&quot;); &#125;); NSLog(@&quot;bbbbb&quot;); 以上是队列组dispatch_group_t的使用，在所有任务执行完时会调用dispatch_group_notify1234567891011121314151617181920212223242016-09-19 10:29:18.989 ThreadTest[3377:88634] aaaaa2016-09-19 10:29:18.989 ThreadTest[3377:88677] _______02016-09-19 10:29:18.990 ThreadTest[3377:88677] _______12016-09-19 10:29:18.991 ThreadTest[3377:88634] bbbbb2016-09-19 10:29:18.991 ThreadTest[3377:88679] _______112016-09-19 10:29:18.991 ThreadTest[3377:88677] _______22016-09-19 10:29:18.991 ThreadTest[3377:88679] _______122016-09-19 10:29:18.991 ThreadTest[3377:88677] _______32016-09-19 10:29:18.992 ThreadTest[3377:88679] _______132016-09-19 10:29:18.992 ThreadTest[3377:88677] _______42016-09-19 10:29:18.992 ThreadTest[3377:88679] _______142016-09-19 10:29:18.993 ThreadTest[3377:88677] _______52016-09-19 10:29:18.993 ThreadTest[3377:88679] _______152016-09-19 10:29:18.993 ThreadTest[3377:88677] _______62016-09-19 10:29:18.993 ThreadTest[3377:88679] _______162016-09-19 10:29:18.993 ThreadTest[3377:88677] _______72016-09-19 10:29:18.993 ThreadTest[3377:88679] _______172016-09-19 10:29:18.993 ThreadTest[3377:88677] _______82016-09-19 10:29:18.994 ThreadTest[3377:88679] _______182016-09-19 10:29:18.995 ThreadTest[3377:88677] _______92016-09-19 10:29:18.995 ThreadTest[3377:88679] _______192016-09-19 10:29:18.995 ThreadTest[3377:88677] _______102016-09-19 10:29:18.995 ThreadTest[3377:88679] _______202016-09-19 10:29:19.089 ThreadTest[3377:88634] _______完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 持续集成（一）]]></title>
      <url>%2F2016%2F12%2F07%2FiOS-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[码字不易，转载请注明出处。 前言iOS常用的持续集成工具有Jenkins、Travis CI、Xcode server等，当然我们选择最简单的Xcode server。 OS X server中集成了git版本管理功能，Xcode server持续集成服务，还有wiki知识库管理等，你甚至还可以拿它搭建一个网站服务器。 在持续集成过程中你可以直接使用os x server 的git版本管理功能，将代码提交至自己搭建的OS X server服务器。也可以将代码提交至其他git版本管理仓库中(比如GitHub)。设备一台Git服务器，可以用GitHub、oschina等。 一台装OS X Server的服务器，必须为MAC，下文简称 Xcode Server服务器。 若干MAC做客户端，下文简称客户端。 若干台iOS测试机。 一、配置Xcode Server服务器1、apple给开发者可以凭开发者账号免费兑换os x server。免费兑换地址 https://developer.apple.com/osx/download/ 2、下载os x server后点击安装。 3、打开 Server 应用，以查看 OS X Server 中提供的服务列表。选择“Xcode”。 点按“选取 Xcode”按钮，然后在“应用程序”文件夹中选择“Xcode”。Xcode 服务将自动启动。 4、开发者团队 在此处千万不要添加开发者账号 5、添加git存储库，如果用Github、oschina或者自己搭建的git服务器则不需要此步骤。 Xcode 服务 Bot 将从源 Git 储存库访问项目和代码。 点按“储存库”，然后点按 添加按钮。选取 Git 储存库的名称，然后点按“创建”。 储存库的 URL 基于服务器主机名称和储存库名称。例如，储存库的 URL 将为 https://myserver.example.com/git/Mac_Calc.git。 二、配置Xcode客户端，创建bot1、打开xcode&gt;product&gt;create bot 2、填写bot名称，选择Xcode Server服务器 3、Actions：选择执行的动作 a、对代码进行静态分析 b、对代码进行单元测试 c、生成archive包（可以选择是否生成用户安装包） 4、cleaning：选择在何时清理项目，有几个选项（总是、每天、每周、从不） 5、configuration：选择编译配置（Debug、release） 6、选择在何时Xcode Server服务器开始持续集成，有几个选项（定时、在有新代码提交时、手动） 7、Before Integration 在开始持续集成前执行的脚本 8、 After Integration在持续集成后执行的脚本 9、至此，创建bot完成 三、Xcode Server服务器证书配置 1、配置Certificates 打开钥匙串，将iPhone Developer: xxx和iPhone Distribution:xxx导出为.p12文件 将导出的.p12文件 导入装OS X Server的MAC的钥匙串中，这次需导入到钥匙串系统中，而不是登录中 持续集成生成包时证书由/usr/bin/codesign管理，所以需将codesign添加为允许访问证书的程序 在显示简介中选择 访问控制 &gt;始终通过这些应用程序访问 中点击加号，开始选择/usr/bin/codesign程序。选择完成后点击确认。由于usr是隐藏文件，在选择时使用快捷键 CMD+SHIFT+. 显示隐藏文件 按照以上步骤将iPhone Distribution:xxx的访问控制，也添加/usr/bin/codesign程序。 2、将Provisioning Profiles拷贝到Xcode Server Xcode客户端描述文件保存在以下文件夹中 User/Library/MobileDevice/ProvisioningProfiles Xcode Server服务器描述文件保存在以下文件夹中 /Library/Developer/XcodeServer/ProvisioningProfiles 将Xcode客户端路径下的证书保存至Xcode Server服务器对应路径下 3、在上传代码到仓库时需选择正确的证书和描述文件，如下图 四、开始持续集成点击integrate开始持续集成 正常情况等待几分钟会看到下面的界面，说明持续集成完成。可以将ipa包安装到手机，也可以将Archive上传到appStore。当然也可以直接用iPhone Safari访问xcode server进行安装。 iOS Xcode server 持续集成（二）集成后ipa包自动上传蒲公英 集成前执行pod install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
